#!/usr/bin/env python3
import argparse
import os
from pathlib import Path

import matplotlib.pyplot as plt
import pandas as pd

ROOT_DIR = Path(__file__).resolve().parents[2]


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description='Plot NC1-NC4 curves directly from precomputed CSV (no checkpoint re-evaluation).')
    parser.add_argument(
        '--csv-path',
        type=str,
        default='results/cifar100_resnet18_32x32_base_e100_lr0.1_default/nc1-4_by_seed_epoch.csv',
        help='Path to CSV generated by step3_compute_nc1-4.sh')
    parser.add_argument(
        '--seed-dirs',
        type=str,
        default='',
        help='Optional comma-separated seed dirs to keep, e.g. s0,s1,s2')
    parser.add_argument(
        '--epochs',
        type=str,
        default='',
        help='Optional comma-separated epochs to keep, e.g. 10,20,30,...')
    parser.add_argument(
        '--output-dir',
        type=str,
        default='results/cifar100_resnet18_32x32_base_e100_lr0.1_default/plots',
        help='Directory for output figures and aggregated tables')
    return parser.parse_args()


def make_curve_plot(df_agg: pd.DataFrame, metric: str, out_path: Path):
    y = f'{metric}_mean'
    yerr = f'{metric}_std_across_seed'

    plt.figure(figsize=(8, 5))
    x = df_agg['epoch_num'].to_numpy()
    m = df_agg[y].to_numpy()
    s = df_agg[yerr].to_numpy()

    plt.plot(x, m, marker='o', linewidth=2)
    plt.fill_between(x, m - s, m + s, alpha=0.2)
    plt.xlabel('Epoch')
    plt.ylabel(metric.upper())
    plt.title(f'{metric.upper()} vs Epoch')
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.savefig(out_path, dpi=200)
    plt.close()


def make_combined_plot(df_agg: pd.DataFrame, out_path: Path):
    plt.figure(figsize=(9, 5.5))
    x = df_agg['epoch_num'].to_numpy()
    for metric in ['nc1', 'nc2', 'nc3', 'nc4']:
        y = df_agg[f'{metric}_mean'].to_numpy()
        plt.plot(x, y, marker='o', linewidth=2, label=metric.upper())

    plt.xlabel('Epoch')
    plt.ylabel('Metric Value')
    plt.title('NC1-NC4 vs Epoch (Mean Across Seeds)')
    plt.grid(True, alpha=0.3)
    plt.legend()
    plt.tight_layout()
    plt.savefig(out_path, dpi=200)
    plt.close()


def main():
    args = parse_args()

    csv_path = (ROOT_DIR / args.csv_path).resolve() if not os.path.isabs(args.csv_path) else Path(args.csv_path)
    out_dir = (ROOT_DIR / args.output_dir).resolve() if not os.path.isabs(args.output_dir) else Path(args.output_dir)
    out_dir.mkdir(parents=True, exist_ok=True)

    if not csv_path.exists():
        raise FileNotFoundError(f'CSV not found: {csv_path}')

    df = pd.read_csv(csv_path)

    required_cols = ['seed_dir', 'epoch', 'epoch_num', 'status', 'nc1', 'nc2', 'nc3', 'nc4']
    missing_cols = [c for c in required_cols if c not in df.columns]
    if missing_cols:
        raise ValueError(f'CSV missing required columns: {missing_cols}')

    # Keep only successful rows.
    df = df[df['status'] == 'ok'].copy()

    # Optional seed filtering.
    if args.seed_dirs.strip():
        keep_seeds = {s.strip() for s in args.seed_dirs.split(',') if s.strip()}
        df = df[df['seed_dir'].astype(str).isin(keep_seeds)].copy()

    # Keep only numeric epochs (exclude "best" by default for curve plotting).
    # Use robust numeric parsing instead of regex to avoid escaping issues.
    df = df[pd.to_numeric(df['epoch'], errors='coerce').notna()].copy()
    df['epoch_num'] = pd.to_numeric(df['epoch_num'], errors='coerce')
    df = df[df['epoch_num'].notna()].copy()
    df['epoch_num'] = df['epoch_num'].astype(int)

    # Optional epoch filtering.
    if args.epochs.strip():
        keep_epochs = {int(x.strip()) for x in args.epochs.split(',') if x.strip()}
        df = df[df['epoch_num'].isin(keep_epochs)].copy()

    if len(df) == 0:
        raise ValueError('No rows left after filtering. Check status/seed/epoch filters.')

    # Save filtered rows for transparency.
    filtered_csv = out_dir / 'nc1-4_filtered_rows.csv'
    df.sort_values(['seed_dir', 'epoch_num']).to_csv(filtered_csv, index=False)

    # Aggregate by epoch (mean/std across seeds).
    rows = []
    for epoch_num, sub in df.groupby('epoch_num'):
        rows.append({
            'epoch_num': int(epoch_num),
            'num_seeds': int(sub['seed_dir'].nunique()),
            'nc1_mean': sub['nc1'].mean(),
            'nc1_std_across_seed': sub['nc1'].std(ddof=0),
            'nc2_mean': sub['nc2'].mean(),
            'nc2_std_across_seed': sub['nc2'].std(ddof=0),
            'nc3_mean': sub['nc3'].mean(),
            'nc3_std_across_seed': sub['nc3'].std(ddof=0),
            'nc4_mean': sub['nc4'].mean(),
            'nc4_std_across_seed': sub['nc4'].std(ddof=0),
        })

    df_agg = pd.DataFrame(rows).sort_values('epoch_num').reset_index(drop=True)
    agg_csv = out_dir / 'nc1-4_aggregate_by_epoch.csv'
    df_agg.to_csv(agg_csv, index=False)

    # Individual curves.
    make_curve_plot(df_agg, 'nc1', out_dir / 'nc1_vs_epoch.png')
    make_curve_plot(df_agg, 'nc2', out_dir / 'nc2_vs_epoch.png')
    make_curve_plot(df_agg, 'nc3', out_dir / 'nc3_vs_epoch.png')
    make_curve_plot(df_agg, 'nc4', out_dir / 'nc4_vs_epoch.png')

    # Combined figure.
    make_combined_plot(df_agg, out_dir / 'nc1-4_vs_epoch_combined.png')

    print(f'Input CSV: {csv_path}')
    print(f'Filtered rows: {filtered_csv}')
    print(f'Aggregate CSV: {agg_csv}')
    print(f'Figures saved under: {out_dir}')


if __name__ == '__main__':
    main()
